diff --git a/arch/arm/configs/msm8930_serrano_spr_defconfig b/arch/arm/configs/msm8930_serrano_spr_defconfig
index 1d85cb9..10a94bf 100644
--- a/arch/arm/configs/msm8930_serrano_spr_defconfig
+++ b/arch/arm/configs/msm8930_serrano_spr_defconfig
@@ -1,6 +1,52 @@
+# This needs cleaned up, I suspect a lot of this is unnecessary.
+
 CONFIG_MACH_SERRANO_SPR=y
 CONFIG_2MIC_QUP_I2C=y
 CONFIG_2MIC_ES305=y
 CONFIG_2MIC_QUP_I2C_GSBI11=y
 CONFIG_AUTHENTEC_VPNCLIENT_INTERCEPTOR=m
 CONFIG_KEYBOARD_CYPRESS_TOUCH=y
+
+# Only one of these at a time
+# egrep CONFIG_CHARGER include/linux/battery/sec_charger.h | sed -re 's/#(el)?if\ defined\(//'
+#CONFIG_CHARGER_DUMMY=n
+#CONFIG_CHARGER_MAX8903=n
+#CONFIG_CHARGER_SMB328=n
+#CONFIG_CHARGER_SMB347=n
+#CONFIG_CHARGER_SMB358=n
+#CONFIG_CHARGER_BQ24157=n
+#CONFIG_CHARGER_BQ24190=n
+#CONFIG_CHARGER_BQ24191=n
+#CONFIG_CHARGER_BQ24260=n
+#CONFIG_CHARGER_NCP1851=n
+#CONFIG_CHARGER_TSU8111=n
+
+CONFIG_POWER_SUPPLY=y
+
+CONFIG_CHARGER_MAX77XXX=y
+CONFIG_CHARGER_MAX77803=y
+
+CONFIG_MFD_PM8921_CORE=y
+CONFIG_MFD_PM8821_CORE=y
+CONFIG_MFD_PM8038_CORE=y
+CONFIG_MFD_PM8XXX_SPK=y
+CONFIG_MFD_PM8XXX_BATT_ALARM=y
+CONFIG_MFD_MAX77693=y
+
+CONFIG_PM8921_BMS=n
+CONFIG_PM8921_CHARGER=y
+CONFIG_PM8921_SEC_CHARGER=n
+CONFIG_MFD_PM8921_CORE=y
+
+CONFIG_FUELGAUGE_MAX17048=y
+
+CONFIG_BATTERY_SAMSUNG=y
+CONFIG_SEC_DEBUG=y
+CONFIG_SEC_DEBUG_SCHED_LOG=y
+CONFIG_SEC_DEBUG_SUBSYS=y
+
+CONFIG_USB_SWITCH_TSU6721=n
+CONFIG_SERIAL_MSM_HS=y
+CONFIG_USB_CI13XXX_MSM_HSIC=y
+
+
diff --git a/arch/arm/configs/msm8930_serrano_usa_defconfig b/arch/arm/configs/msm8930_serrano_usa_defconfig
index 82f2239..10604b8 100644
--- a/arch/arm/configs/msm8930_serrano_usa_defconfig
+++ b/arch/arm/configs/msm8930_serrano_usa_defconfig
@@ -37,6 +37,7 @@ CONFIG_ARCH_MSM8960=y
 CONFIG_ARCH_MSM8930=y
 CONFIG_MSM_KRAIT_TBB_ABORT_HANDLER=y
 CONFIG_MACH_SERRANO=y
+CONFIG_MACH_SERRANO_SPR=y
 # CONFIG_MSM_STACKED_MEMORY is not set
 CONFIG_KERNEL_MSM_CONTIG_MEM_REGION=y
 # CONFIG_MSM_FIQ_SUPPORT is not set
diff --git a/arch/arm/mach-msm/Makefile b/arch/arm/mach-msm/Makefile
index a89843e..d153667 100644
--- a/arch/arm/mach-msm/Makefile
+++ b/arch/arm/mach-msm/Makefile
@@ -280,7 +280,7 @@ obj-$(CONFIG_MACH_MSM8930_EVT) += board-8930-all.o board-8930-regulator-pm8038.o
 obj-$(CONFIG_MACH_EXPRESS2) += board-express2.o board-8930-camera-power.o board-8930-camera.o board-8930-display.o board-8930-pmic.o board-8930-storage.o board-express2-gpiomux.o devices-8930.o board-8930-gpu.o board-8930-regulator-pm8038.o board-8930-regulator-pm8917.o board-8930-input-mxt.o board-8930-input-tkey.o
 obj-$(CONFIG_MACH_EXPRESS) += board-express.o board-8930-camera-power.o board-8930-camera.o board-8930-display.o board-8930-pmic.o board-8930-storage.o board-express-gpiomux.o devices-8930.o board-8930-gpu.o board-8930-regulator-pm8038.o board-8930-regulator-pm8917.o board-8930-input-mxt.o board-8930-input-tkey.o
 obj-$(CONFIG_MACH_HIGGS) += board-higgs.o board-8930-camera-power.o board-8930-camera.o board-8930-display.o board-8930-pmic.o board-8930-storage.o board-higgs-gpiomux.o devices-8930.o board-8930-gpu.o board-8930-regulator-pm8038.o board-8930-regulator-pm8917.o board-8930-input-mms.o
-obj-$(CONFIG_MACH_SERRANO) += board-serrano.o board-8930-camera-power.o board-8930-camera.o board-8930-display.o board-8930-pmic.o board-8930-storage.o board-serrano-gpiomux.o devices-8930.o board-8930-gpu.o board-8930-regulator-pm8038.o board-8930-regulator-pm8917.o board-8930-input-mxt.o board-8930-input-tkey.o
+obj-$(CONFIG_MACH_SERRANO) += board-serrano.o board-8930-camera-power.o board-8930-camera.o board-8930-display.o board-8930-pmic.o board-8930-storage.o board-serrano-gpiomux.o devices-8930.o board-8930-gpu.o board-8930-regulator-pm8038.o board-8930-regulator-pm8917.o board-8930-input-mxt.o board-8930-input-tkey-serrano.o
 obj-$(CONFIG_MACH_CRATER) += board-crater.o board-8930-camera-power.o board-8930-camera.o board-8930-display.o board-8930-pmic.o board-8930-storage.o board-crater-gpiomux.o devices-8930.o board-8930-gpu.o board-8930-regulator-pm8038.o board-8930-regulator-pm8917.o board-8930-input-mxt.o board-8930-input-tkey.o
 obj-$(CONFIG_MACH_BAFFIN) += board-baffin.o board-8930-camera-power.o board-8930-camera.o board-8930-display.o board-8930-pmic.o board-8930-storage.o board-baffin-gpiomux.o devices-8930.o board-8930-gpu.o board-8930-regulator-pm8038.o board-8930-regulator-pm8917.o board-8930-input-mxt.o board-8930-input-tkey.o
 obj-$(CONFIG_MACH_JASPER2) += board-jasper2.o board-8930-camera-power.o board-8930-camera.o board-8930-display.o board-8930-pmic.o board-8930-storage.o board-jasper2-gpiomux.o devices-8930.o board-8930-gpu.o board-8930-regulator-pm8038.o board-8930-regulator-pm8917.o
diff --git a/arch/arm/mach-msm/acpuclock-8930ab.c b/arch/arm/mach-msm/acpuclock-8930ab.c
index 63fd725..59f0e14 100644
--- a/arch/arm/mach-msm/acpuclock-8930ab.c
+++ b/arch/arm/mach-msm/acpuclock-8930ab.c
@@ -276,7 +276,7 @@ static struct acpu_level tbl_PVS6_1700MHz[] __initdata = {
 	{ 0, { 0 } }
 };
 
-#if defined(CONFIG_MACH_MELIUS_SKT)||defined(CONFIG_MACH_MELIUS_LGT)||defined(CONFIG_MACH_MELIUS_KTT)
+#if defined(CONFIG_MACH_MELIUS_SKT)||defined(CONFIG_MACH_MELIUS_LGT)||defined(CONFIG_MACH_MELIUS_KTT)||defined(CONFIG_MACH_SERRANO_SPR)
 static struct pvs_table pvs_tables[NUM_SPEED_BINS][NUM_PVS] __initdata = {
 	[0][0] = { tbl_PVS0_1700MHz, sizeof(tbl_PVS0_1700MHz), 25000 },
 	[0][1] = { tbl_PVS1_1700MHz, sizeof(tbl_PVS1_1700MHz), 50000 },
diff --git a/arch/arm/mach-msm/acpuclock-krait.c b/arch/arm/mach-msm/acpuclock-krait.c
index ecb8f01..02b8b06 100644
--- a/arch/arm/mach-msm/acpuclock-krait.c
+++ b/arch/arm/mach-msm/acpuclock-krait.c
@@ -434,7 +434,7 @@ module_param_named(boost, enable_boost, bool, S_IRUGO | S_IWUSR);
 
 static int calculate_vdd_core(const struct acpu_level *tgt)
 {
-#if defined(CONFIG_MACH_MELIUS_SKT)||defined(CONFIG_MACH_MELIUS_LGT)||defined(CONFIG_MACH_MELIUS_KTT)
+#if defined(CONFIG_MACH_MELIUS_SKT)||defined(CONFIG_MACH_MELIUS_LGT)||defined(CONFIG_MACH_MELIUS_KTT)||defined(CONFIG_MACH_SERRANO_SPR)
 	return tgt->vdd_core + drv.boost_uv ;
 #else
 	return tgt->vdd_core + (enable_boost ? drv.boost_uv : 0);
diff --git a/arch/arm/mach-msm/include/mach/serrano-gpio.h b/arch/arm/mach-msm/include/mach/serrano-gpio.h
index 4b52826..7315394 100644
--- a/arch/arm/mach-msm/include/mach/serrano-gpio.h
+++ b/arch/arm/mach-msm/include/mach/serrano-gpio.h
@@ -55,11 +55,10 @@
 #ifdef CONFIG_USB_SWITCH_TSU6721
 #define GPIO_USB_I2C_SDA		101 
 #define GPIO_USB_I2C_SCL        100 
-#else
+#endif
 #define GPIO_IF_PMIC_SDA		101 
 #define GPIO_IF_PMIC_SCL        100 
 #define GPIO_IF_PMIC_IRQ		14
-#endif
 #define GPIO_HALL_SENSOR_INT	78
 #define GPIO_TSP_D_EN			79
 #define GPIO_TSP_A_EN			80
@@ -82,7 +81,7 @@
 #define GPIO_SPKR_I2S_RX_WS		62
 
 #if defined (CONFIG_MACH_SERRANO_ATT) || defined(CONFIG_MACH_SERRANO_VZW)\
-	|| defined(CONFIG_MACH_SERRANO_LRA)
+	|| defined(CONFIG_MACH_SERRANO_LRA) || defined(CONFIG_MACH_SERRANO_SPR)
 #define GPIO_VPS_AMP_EN		PM8038_GPIO_PM_TO_SYS(14)
 #else
 #define GPIO_VPS_AMP_EN		0
diff --git a/drivers/tty/serial/msm_serial_hs.c b/drivers/tty/serial/msm_serial_hs.c
index 8d60f33..a78b5b0 100644
--- a/drivers/tty/serial/msm_serial_hs.c
+++ b/drivers/tty/serial/msm_serial_hs.c
@@ -55,6 +55,7 @@
 #include <linux/device.h>
 #include <linux/wakelock.h>
 #include <linux/debugfs.h>
+#include <linux/gpio.h>
 #include <asm/atomic.h>
 #include <asm/irq.h>
 
@@ -144,6 +145,15 @@ struct msm_hs_wakeup {
 	char rx_to_inject;
 };
 
+/*
+ * UART can be used in 2-wire or 4-wire mode.
+ * Use uart_func_mode to set 2-wire or 4-wire mode.
+ */
+enum uart_func_mode {
+	UART_TWO_WIRE, /* can't support HW Flow control. */
+	UART_FOUR_WIRE,/* can support HW Flow control. */
+};
+
 struct msm_hs_port {
 	struct uart_port uport;
 	unsigned int imr_reg;  /* shadow value of UARTDM_IMR */
@@ -172,6 +182,7 @@ struct msm_hs_port {
 	struct workqueue_struct *hsuart_wq; /* hsuart workqueue */
 	struct mutex clk_mutex; /* mutex to guard against clock off/clock on */
 	bool rx_discard_flush_issued;
+	enum uart_func_mode func_mode;
 	bool is_shutdown;
 	bool termios_in_progress;
 };
@@ -486,6 +497,133 @@ static int __devexit msm_hs_remove(struct platform_device *pdev)
 	return 0;
 }
 
+/**
+ * msm_hs_config_uart_tx_rx_gpios - Configures UART Tx and RX GPIOs
+ * @port: uart port
+ */
+static int msm_hs_config_uart_tx_rx_gpios(struct uart_port *uport)
+{
+	struct platform_device *pdev = to_platform_device(uport->dev);
+	const struct msm_serial_hs_platform_data *pdata =
+					pdev->dev.platform_data;
+	int ret = -EINVAL;
+
+
+	ret = gpio_request(pdata->uart_tx_gpio, "UART_TX_GPIO");
+	if (unlikely(ret)) {
+		pr_err("gpio request failed for:%d\n",
+				pdata->uart_tx_gpio);
+		goto exit_uart_config;
+	}
+
+	ret = gpio_request(pdata->uart_rx_gpio, "UART_RX_GPIO");
+	if (unlikely(ret)) {
+		pr_err("gpio request failed for:%d\n",
+				pdata->uart_rx_gpio);
+		gpio_free(pdata->uart_tx_gpio);
+		goto exit_uart_config;
+	}
+
+exit_uart_config:
+	return ret;
+}
+
+/**
+ * msm_hs_unconfig_uart_tx_rx_gpios: Unconfigures UART Tx and RX GPIOs
+ * @port: uart port
+ */
+static void msm_hs_unconfig_uart_tx_rx_gpios(struct uart_port *uport)
+{
+	struct platform_device *pdev = to_platform_device(uport->dev);
+	const struct msm_serial_hs_platform_data *pdata =
+						pdev->dev.platform_data;
+
+
+	gpio_free(pdata->uart_tx_gpio);
+	gpio_free(pdata->uart_rx_gpio);
+
+}
+
+/**
+ * msm_hs_config_uart_hwflow_gpios: Configures UART HWFlow GPIOs
+ * @port: uart port
+ */
+static int msm_hs_config_uart_hwflow_gpios(struct uart_port *uport)
+{
+	struct platform_device *pdev = to_platform_device(uport->dev);
+	const struct msm_serial_hs_platform_data *pdata =
+						pdev->dev.platform_data;
+	int ret = -EINVAL;
+
+	ret = gpio_request(pdata->uart_cts_gpio, "UART_CTS_GPIO");
+	if (unlikely(ret)) {
+		pr_err("gpio request failed for:%d\n", pdata->uart_cts_gpio);
+		goto exit_config_uart;
+	}
+
+	ret = gpio_request(pdata->uart_rfr_gpio, "UART_RFR_GPIO");
+	if (unlikely(ret)) {
+		pr_err("gpio request failed for:%d\n", pdata->uart_rfr_gpio);
+		gpio_free(pdata->uart_cts_gpio);
+		goto exit_config_uart;
+	}
+
+exit_config_uart:
+	return ret;
+}
+
+/**
+ * msm_hs_unconfig_uart_hwflow_gpios: Unonfigures UART HWFlow GPIOs
+ * @port: uart port
+ */
+static void msm_hs_unconfig_uart_hwflow_gpios(struct uart_port *uport)
+{
+	struct platform_device *pdev = to_platform_device(uport->dev);
+	const struct msm_serial_hs_platform_data *pdata =
+						pdev->dev.platform_data;
+
+	gpio_free(pdata->uart_cts_gpio);
+	gpio_free(pdata->uart_rfr_gpio);
+
+}
+
+/**
+ * msm_hs_config_uart_gpios: Configures UART GPIOs and returns success or
+ * Failure
+ * @port: uart port
+ */
+static int msm_hs_config_uart_gpios(struct uart_port *uport)
+{
+	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
+	int ret;
+
+	/* Configure UART Tx and Rx GPIOs */
+	ret = msm_hs_config_uart_tx_rx_gpios(uport);
+	if (!ret) {
+		if (msm_uport->func_mode == UART_FOUR_WIRE) {
+			/*if 4-wire uart, configure CTS and RFR GPIOs */
+			ret = msm_hs_config_uart_hwflow_gpios(uport);
+			if (ret)
+				msm_hs_unconfig_uart_tx_rx_gpios(uport);
+		}
+	}
+
+	return ret;
+}
+
+/**
+ * msm_hs_unconfig_uart_gpios: Unconfigures UART GPIOs
+ * @port: uart port
+ */
+static void msm_hs_unconfig_uart_gpios(struct uart_port *port)
+{
+	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(port);
+
+	msm_hs_unconfig_uart_tx_rx_gpios(port);
+	if (msm_uport->func_mode == UART_FOUR_WIRE)
+		msm_hs_unconfig_uart_hwflow_gpios(port);
+}
+
 static int msm_hs_init_clk(struct uart_port *uport)
 {
 	int ret;
@@ -866,7 +1004,6 @@ static void msm_hs_set_termios(struct uart_port *uport,
 	 * On receiving this interrupt, send discard flush request
 	 * to ADM driver and ignore all received data.
 	 */
-	wake_lock(&msm_uport->rx.wake_lock);
 	msm_hs_write(uport, UARTDM_CR_ADDR, FORCE_STALE_EVENT);
 	mb();
 
@@ -881,7 +1018,7 @@ static void msm_hs_set_termios(struct uart_port *uport,
 		spin_unlock_irqrestore(&uport->lock, flags);
 		ret = wait_event_timeout(msm_uport->rx.wait,
 			msm_uport->rx_discard_flush_issued == false,
-			msecs_to_jiffies(300));
+			msecs_to_jiffies(50));
 			if (!ret) {
 				pr_err("%s(): timeout for rx discard flush\n",
 								__func__);
@@ -1539,7 +1676,6 @@ static int msm_hs_check_clock_off(struct uart_port *uport)
 	switch (msm_uport->clk_req_off_state) {
 	case CLK_REQ_OFF_START:
 		msm_uport->clk_req_off_state = CLK_REQ_OFF_RXSTALE_ISSUED;
-		wake_lock(&msm_uport->rx.wake_lock);
 		msm_hs_write(uport, UARTDM_CR_ADDR, FORCE_STALE_EVENT);
 		/*
 		 * Before returning make sure that device writel completed.
@@ -1741,12 +1877,6 @@ void msm_hs_request_clock_off(struct uart_port *uport) {
 	struct msm_hs_port *msm_uport = UARTDM_TO_MSM(uport);
 
 	spin_lock_irqsave(&uport->lock, flags);
-	if (msm_uport->is_shutdown) {
-		pr_err("%s:Clock OFF fail.UART port is closed\n", __func__);
-		spin_unlock_irqrestore(&uport->lock, flags);
-		return;
-	}
-
 	if (msm_uport->clk_state == MSM_HS_CLK_ON) {
 		msm_uport->clk_state = MSM_HS_CLK_REQUEST_OFF;
 		msm_uport->clk_req_off_state = CLK_REQ_OFF_START;
@@ -1772,13 +1902,6 @@ void msm_hs_request_clock_on(struct uart_port *uport)
 	mutex_lock(&msm_uport->clk_mutex);
 	spin_lock_irqsave(&uport->lock, flags);
 
-	if (msm_uport->is_shutdown) {
-		pr_err("%s:Clock ON fail.UART port is closed\n", __func__);
-		spin_unlock_irqrestore(&uport->lock, flags);
-		mutex_unlock(&msm_uport->clk_mutex);
-		return;
-	}
-
 	switch (msm_uport->clk_state) {
 	case MSM_HS_CLK_OFF:
 		wake_lock(&msm_uport->dma_wake_lock);
@@ -1789,7 +1912,6 @@ void msm_hs_request_clock_on(struct uart_port *uport)
 			wake_unlock(&msm_uport->dma_wake_lock);
 			dev_err(uport->dev, "Clock ON Failure"
 			"For UART CLK Stalling HSUART\n");
-			wake_unlock(&msm_uport->dma_wake_lock);
 			break;
 		}
 
@@ -1800,7 +1922,6 @@ void msm_hs_request_clock_on(struct uart_port *uport)
 				clk_disable_unprepare(msm_uport->clk);
 				dev_err(uport->dev, "Clock ON Failure"
 				"For UART Pclk Stalling HSUART\n");
-				wake_unlock(&msm_uport->dma_wake_lock);
 				break;
 			}
 		}
@@ -1829,8 +1950,7 @@ void msm_hs_request_clock_on(struct uart_port *uport)
 		break;
 	}
 
-	if (!ret)
-		spin_unlock_irqrestore(&uport->lock, flags);
+	spin_unlock_irqrestore(&uport->lock, flags);
 	mutex_unlock(&msm_uport->clk_mutex);
 }
 EXPORT_SYMBOL(msm_hs_request_clock_on);
@@ -1913,9 +2033,13 @@ static int msm_hs_startup(struct uart_port *uport)
 		return ret;
 	}
 
-	if (pdata && pdata->gpio_config)
-		if (unlikely(pdata->gpio_config(1)))
-			dev_err(uport->dev, "Cannot configure gpios\n");
+	if (pdata && pdata->config_gpio) {
+		ret = msm_hs_config_uart_gpios(uport);
+		if (ret)
+			goto deinit_uart_clk;
+	} else {
+		pr_debug("%s(): UART GPIOs not specified.\n", __func__);
+	}
 
 	/* Set auto RFR Level */
 	data = msm_hs_read(uport, UARTDM_MR1_ADDR);
@@ -1990,7 +2114,7 @@ static int msm_hs_startup(struct uart_port *uport)
 		ret = irq_set_irq_wake(msm_uport->wakeup.irq, 1);
 		if (unlikely(ret)) {
 			pr_err("%s():Err setting wakeup irq\n", __func__);
-			goto deinit_uart_clk;
+			goto unconfigure_uart_gpio;
 		}
 	}
 
@@ -2030,6 +2154,9 @@ free_uart_irq:
 	free_irq(uport->irq, msm_uport);
 free_wake_irq:
 	irq_set_irq_wake(msm_uport->wakeup.irq, 0);
+unconfigure_uart_gpio:
+	if (pdata && pdata->config_gpio)
+		msm_hs_unconfig_uart_gpios(uport);
 deinit_uart_clk:
 	clk_disable_unprepare(msm_uport->clk);
 	if (msm_uport->pclk)
@@ -2208,6 +2335,38 @@ static int __devinit msm_hs_probe(struct platform_device *pdev)
 
 	}
 
+	/* Identify UART functional mode as 2-wire or 4-wire. */
+	if (pdata && pdata->config_gpio) {
+		switch (pdata->config_gpio) {
+		case 4:
+			if (gpio_is_valid(pdata->uart_tx_gpio)
+				&& gpio_is_valid(pdata->uart_rx_gpio)
+				&& gpio_is_valid(pdata->uart_cts_gpio)
+				&& gpio_is_valid(pdata->uart_rfr_gpio)) {
+					msm_uport->func_mode = UART_FOUR_WIRE;
+			} else {
+				pr_err("%s(): Wrong GPIO Number for 4-Wire.\n",
+								__func__);
+				return -EINVAL;
+			}
+			break;
+		case 2:
+			if (gpio_is_valid(pdata->uart_tx_gpio)
+				&& gpio_is_valid(pdata->uart_rx_gpio)) {
+					msm_uport->func_mode = UART_TWO_WIRE;
+			} else {
+				pr_err("%s(): Wrong GPIO Number for 2-Wire.\n",
+								__func__);
+				return -EINVAL;
+			}
+			break;
+		default:
+			pr_err("%s(): Invalid number of GPIOs.\n", __func__);
+			pdata->config_gpio = 0;
+			return -EINVAL;
+		}
+	}
+
 	resource = platform_get_resource_byname(pdev, IORESOURCE_DMA,
 						"uartdm_channels");
 	if (unlikely(!resource))
@@ -2228,7 +2387,6 @@ static int __devinit msm_hs_probe(struct platform_device *pdev)
 	uport->flags = UPF_BOOT_AUTOCONF;
 	uport->uartclk = 7372800;
 	msm_uport->imr_reg = 0x0;
-	msm_uport->is_shutdown = true;
 
 	msm_uport->clk = clk_get(&pdev->dev, "core_clk");
 	if (IS_ERR(msm_uport->clk))
@@ -2448,9 +2606,8 @@ static void msm_hs_shutdown(struct uart_port *uport)
 	if (use_low_power_wakeup(msm_uport))
 		free_irq(msm_uport->wakeup.irq, msm_uport);
 
-	if (pdata && pdata->gpio_config)
-		if (pdata->gpio_config(0))
-			dev_err(uport->dev, "GPIO config error\n");
+	if (pdata && pdata->config_gpio)
+			msm_hs_unconfig_uart_gpios(uport);
 }
 
 static void __exit msm_serial_hs_exit(void)
diff --git a/include/linux/i2c/cypress_touchkey.h b/include/linux/i2c/cypress_touchkey.h
index 549ea70..24b566c 100644
--- a/include/linux/i2c/cypress_touchkey.h
+++ b/include/linux/i2c/cypress_touchkey.h
@@ -14,7 +14,7 @@
 extern struct class *sec_class;
 extern int ISSP_main(void);
 extern int touch_is_pressed;
-extern int system_rev;
+extern unsigned int system_rev;
 
 #include <linux/i2c.h>
 #include <linux/delay.h>
